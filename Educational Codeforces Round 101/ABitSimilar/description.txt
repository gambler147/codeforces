Let's call two strings ğ‘ and ğ‘ (both of length ğ‘˜) a bit similar if they have
the same character in some position, i. e. there exists at least one ğ‘–âˆˆ[1,ğ‘˜]
such that ğ‘ğ‘–=ğ‘ğ‘–.

You are given a binary string ğ‘  of length ğ‘› (a string of ğ‘› characters 0
and/or 1) and an integer ğ‘˜. Let's denote the string ğ‘ [ğ‘–..ğ‘—] as the substring
of ğ‘  starting from the ğ‘–-th character and ending with the ğ‘—-th character
(that is, ğ‘ [ğ‘–..ğ‘—]=ğ‘ ğ‘–ğ‘ ğ‘–+1ğ‘ ğ‘–+2â€¦ğ‘ ğ‘—âˆ’1ğ‘ ğ‘—).

Let's call a binary string ğ‘¡ of length ğ‘˜ beautiful if it is a bit similar to
all substrings of ğ‘  having length exactly ğ‘˜; that is, it is a bit similar to
ğ‘ [1..ğ‘˜],ğ‘ [2..ğ‘˜+1],â€¦,ğ‘ [ğ‘›âˆ’ğ‘˜+1..ğ‘›].

Your goal is to find the lexicographically smallest string ğ‘¡ that is beautiful,
or report that no such string exists. String ğ‘¥ is lexicographically less than
string ğ‘¦ if either ğ‘¥ is a prefix of ğ‘¦ (and ğ‘¥â‰ ğ‘¦), or there exists such ğ‘–
(1â‰¤ğ‘–â‰¤min(|ğ‘¥|,|ğ‘¦|)), that ğ‘¥ğ‘–<ğ‘¦ğ‘–, and for any ğ‘— (1â‰¤ğ‘—<ğ‘–) ğ‘¥ğ‘—=ğ‘¦ğ‘—.

Input The first line contains one integer ğ‘ (1â‰¤ğ‘â‰¤10000) â€” the number of test
cases. Each test case consists of two lines.

The first line of each test case contains two integers ğ‘› and ğ‘˜ (1â‰¤ğ‘˜â‰¤ğ‘›â‰¤106).
The second line contains the string ğ‘ , consisting of ğ‘› characters (each
character is either 0 or 1).

It is guaranteed that the sum of ğ‘› over all test cases does not exceed 106.

Output For each test case, print the answer as follows:

if it is impossible to construct a beautiful string, print one line containing
the string NO (note: exactly in upper case, you can't print No, for example);
otherwise, print two lines. The first line should contain the string YES
(exactly in upper case as well); the second line â€” the lexicographically
smallest beautiful string, consisting of ğ‘˜ characters 0 and/or 1.