You have an array ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› where ğ‘ğ‘–=ğ‘–.

In one step, you can choose two indices ğ‘¥ and ğ‘¦ (ğ‘¥â‰ ğ‘¦) and set
ğ‘ğ‘¥=âŒˆğ‘ğ‘¥ğ‘ğ‘¦âŒ‰ (ceiling function).

Your goal is to make array ğ‘ consist of ğ‘›âˆ’1 ones and 1 two in no more than
ğ‘›+5 steps. Note that you don't have to minimize the number of steps.

Input The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤1000) â€” the number of
test cases.

The first and only line of each test case contains the single integer ğ‘›
(3â‰¤ğ‘›â‰¤2â‹…105) â€” the length of array ğ‘.

It's guaranteed that the sum of ğ‘› over test cases doesn't exceed 2â‹…105.

Output For each test case, print the sequence of operations that will make ğ‘ as
ğ‘›âˆ’1 ones and 1 two in the following format: firstly, print one integer ğ‘š
(ğ‘šâ‰¤ğ‘›+5) â€” the number of operations; next print ğ‘š pairs of integers ğ‘¥ and ğ‘¦
(1â‰¤ğ‘¥,ğ‘¦â‰¤ğ‘›; ğ‘¥â‰ ğ‘¦) (ğ‘¥ may be greater or less than ğ‘¦) â€” the indices of the
corresponding operation.

It can be proven that for the given constraints it's always possible to find a
correct sequence of operations.